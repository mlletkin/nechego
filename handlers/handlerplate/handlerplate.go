// handlerplate searches the files provided as arguments and generates a
// HandlerID constant and the corresponding Self method for each type
// implementing Handler.
package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"regexp"
	"strings"
)

func main() {
	files := os.Args[1:]
	if len(files) == 0 {
		log.Fatal("no files to process")
	}
	g := generator{}
	for _, name := range files {
		f, err := os.Open(name)
		if err != nil {
			log.Fatalf("opening file: %s", err)
		}
		g.scanTypes(f)
	}

	// The header and package clause.
	g.printf("// Code generated by \"handlerplate %s\"; DO NOT EDIT.\n", strings.Join(files, " "))
	g.printf("package handlers\n")
	g.printf("\n")
	g.printf("type HandlerID int\n")
	g.printf("\n")

	g.generateConstants()
	g.generateMethods()

	src := g.format()
	err := os.WriteFile("handlers_gen.go", src, 0666)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

// generator holds the state of the analysis.
type generator struct {
	types []string
	buf   bytes.Buffer
}

// handlerRE captures the type of a Handle method.
var handlerRE = regexp.MustCompile(`^func \(\w* \*(\w*)\) Handle`)

// scanTypes saves the types implementing Handler from Reader.
func (g *generator) scanTypes(r io.Reader) {
	scan := bufio.NewScanner(r)
	for scan.Scan() {
		line := scan.Text()
		if handlerRE.MatchString(line) {
			t := handlerRE.FindStringSubmatch(line)[1]
			g.types = append(g.types, t)
		}
	}
}

// format returns the gofmt-ed contents of the buffer.
func (g *generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		panic(err)
	}
	return src
}

// printf printfs to the buffer.
func (g *generator) printf(format string, a ...any) {
	fmt.Fprintf(&g.buf, format, a...)
}

// generateMethods produces a Self method for each type.
func (g *generator) generateMethods() {
	for _, t := range g.types {
		g.printf("func (_ *%[1]s) Self() HandlerID { return %[1]sHandler }\n", t)
	}

}

// generateConstants produces a HandlerID constant for each type.
func (g *generator) generateConstants() {
	g.printf("const (\n")
	g.printf("\tNoHandler HandlerID = iota\n")
	for _, t := range g.types {
		g.printf("\t%sHandler\n", t)
	}
	g.printf(")\n\n")
}
